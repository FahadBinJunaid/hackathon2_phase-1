<!--
Sync Impact Report:
- Version: 0.0.0 → 1.0.0 (Initial constitution creation)
- Principles Added: 6 core principles (SDD, Agent-Based, Multi-Tenant, Phase Independence, Cloud-Native, Free-Tier)
- Sections Added: Phase Standards, Code Quality, Security, Agents/Skills, Deliverables, Bonus Strategy, Non-Negotiables, Validation
- Templates Status:
  ✅ spec-template.md - Aligned (user stories with priorities match constitution's phase independence)
  ✅ plan-template.md - Aligned (constitution check gate present, structure supports multi-phase)
  ✅ tasks-template.md - Aligned (phase organization, user story independence, parallel execution)
- Follow-up: None required
- Rationale: MINOR version (1.0.0) - Initial comprehensive constitution establishing all governance principles
-->

# Hackathon II: Todo Spec-Driven Development Constitution

## Core Principles

### I. Spec-Driven Development (SDD)

**No code before specs.** All development MUST follow the strict workflow:

1. `/sp.constitution` → Establish project principles
2. `/sp.specify` → Define feature requirements
3. `/sp.plan` → Design architecture and approach
4. `/sp.tasks` → Break down into actionable tasks
5. `/sp.implement` → Execute implementation

**Rationale**: Prevents scope creep, ensures alignment, enables AI agents to generate correct code on first attempt. All changes MUST go through spec updates; code is generated by AI agents, never manually written without prior specification.

**Non-Negotiable Rules**:
- No implementation without completed spec.md
- No code changes without updating corresponding spec first
- All architectural decisions documented in plan.md before coding
- Tasks.md must be validated before /sp.implement

### II. Agent-Based Architecture

**Specialized agents handle specific domains.** Each agent:
- Has clearly defined responsibilities (auth, backend, database, frontend, AI, DevOps)
- Uses skills from `.claude/skills/` directory
- Coordinates with other agents for complex tasks
- Validates its own work against acceptance criteria

**Rationale**: Enables parallel development, maintains expertise boundaries, ensures consistent patterns within each domain.

**Non-Negotiable Rules**:
- Agents MUST NOT cross domain boundaries without coordination
- Each agent validates its output before completion
- Skills are reusable across phases (write once, use everywhere)
- Agent coordination documented in plan.md for multi-domain features

### III. Multi-Tenant Data Isolation

**Every resource MUST be tied to user_id.** No exceptions.

**Enforcement Layers**:
1. **Database**: All tables include user_id foreign key with indexes
2. **Application**: All queries filtered by authenticated user's ID
3. **API**: JWT tokens carry user_id; middleware validates on every request
4. **Testing**: Multi-tenant test cases required for all CRUD operations

**Rationale**: Prevents data leaks, enables horizontal scaling per user, simplifies compliance (GDPR, data residency).

**Non-Negotiable Rules**:
- No cross-user data access permitted
- All database queries MUST include user_id filter
- JWT tokens required for all authenticated endpoints
- Test cases MUST verify tenant isolation

### IV. Phase Independence & Evolution

**Each phase builds on previous; previous phases remain untouched.**

**Phase Structure**:
- Phase 1: `phase-1/` (Console App - Python, in-memory)
- Phase 2: `phase-2/` (Web App - Next.js + FastAPI + PostgreSQL)
- Phase 3: `phase-3/` (AI Chatbot - OpenAI Agents + MCP)
- Phase 4: `phase-4/` (Local K8s - Docker + Helm + Minikube)
- Phase 5: `phase-5/` (Cloud Deploy - DOKS/OKE + Kafka + Dapr)

**Rationale**: Enables incremental delivery, preserves working versions, allows rollback, demonstrates evolution.

**Non-Negotiable Rules**:
- Each phase in separate folder (no mixing)
- Database schema evolves (adds tables/columns, never drops from previous phases)
- Shared database across phases (phase2 schema namespace)
- Backward compatibility maintained (Phase 2 API works in Phase 3+)

### V. Cloud-Native Architecture

**Stateless services, database as source of truth, event-driven communication.**

**Design Principles**:
- **Stateless**: Services hold no session state (horizontally scalable)
- **Database-Centric**: PostgreSQL is single source of truth
- **Event-Driven**: Kafka for async communication (Phase 5)
- **Containerized**: Docker multi-stage builds for all services
- **Orchestrated**: Kubernetes for deployment (Phases 4-5)

**Rationale**: Enables horizontal scaling, fault tolerance, cloud portability, modern DevOps practices.

**Non-Negotiable Rules**:
- No in-memory session storage (use JWT + database)
- MCP tools MUST be stateless (no conversation state in server)
- All services containerized with health checks
- Kubernetes manifests required for Phases 4-5

### VI. Free-Tier Friendly

**All infrastructure MUST use free or low-cost tiers.**

**Approved Services**:
- **Database**: Neon PostgreSQL (free tier: 0.5GB storage, 1 compute unit)
- **Deployment**: Vercel (free tier: unlimited hobby projects)
- **AI Models**: OpenRouter API (free models: gpt-4o-mini, llama-3.1-8b)
- **Kubernetes**: DigitalOcean DOKS ($12/month) or Oracle OKE (free tier)
- **Events**: Redpanda Cloud (free tier) or Strimzi (self-hosted)

**Rationale**: Removes cost barriers for hackathon participants, demonstrates production-ready architecture on minimal budget.

**Non-Negotiable Rules**:
- No paid-only services without free tier alternative
- Document free tier limits in README.md
- Provide cost estimates for Phase 5 cloud deployment
- Optimize for free tier constraints (connection pooling, efficient queries)

## Phase-Specific Standards

### Phase 1: Console App (Python CLI)

**Technology Stack**:
- Language: Python 3.13+
- Storage: In-memory (lists/dicts)
- Interface: CLI with `input()` prompts
- Features: Add, View, Update, Delete, Mark Complete

**Code Standards**:
- Type hints on all functions
- Docstrings for public functions
- Snake_case naming convention
- No external dependencies (stdlib only)

**Deliverables**:
- `phase-1/main.py` (single file acceptable)
- `phase-1/README.md` (setup instructions)
- Demo video (<90 seconds)

### Phase 2: Full-Stack Web App

**Technology Stack**:
- Frontend: Next.js 16 (App Router), TypeScript, Tailwind CSS
- Backend: FastAPI (async/await), SQLModel ORM
- Database: Neon PostgreSQL (phase2 schema)
- Auth: Better Auth patterns, JWT tokens
- Deployment: Vercel (frontend + backend as serverless functions)

**Code Standards**:
- TypeScript strict mode enabled
- Async/await for all I/O operations
- Pydantic models for request/response validation
- Server Components by default ('use client' only when needed)
- Error boundaries in frontend

**Multi-Tenant Requirements**:
- All tables include `user_id UUID NOT NULL`
- Foreign key constraints to users table
- Indexes on `user_id` for all tables
- All queries filtered by authenticated user

**Deliverables**:
- `phase-2/frontend/` and `phase-2/backend/`
- Published Vercel URL (required)
- Database schema migration scripts
- API documentation (OpenAPI/Swagger)

### Phase 3: AI Chatbot

**Technology Stack**:
- UI: OpenAI ChatKit (React components)
- AI: OpenAI Agents SDK (gpt-4o-mini or free models)
- Tools: Official MCP SDK (5 stateless tools minimum)
- Backend: Extend Phase 2 FastAPI
- Database: Add `conversations` and `messages` tables

**MCP Tool Requirements**:
- Stateless design (no conversation state in server)
- Database-backed (read/write to PostgreSQL)
- Tool definitions in `phase-3/mcp-server/tools/`
- Each tool: name, description, input schema, handler function

**Code Standards**:
- MCP tools return structured JSON
- Error handling for all tool calls
- Conversation history stored in database (not memory)
- Natural language command parsing

**Deliverables**:
- `phase-3/chatbot/` (extends Phase 2)
- MCP server implementation
- Published Vercel URL with chatbot UI
- 5+ working MCP tools

### Phase 4: Local Kubernetes

**Technology Stack**:
- Containerization: Docker (multi-stage builds)
- Orchestration: Minikube or kind (local K8s)
- Package Manager: Helm charts
- AI DevOps: kubectl-ai, kagent (optional)

**Kubernetes Resources**:
- Deployments (frontend, backend, database)
- Services (ClusterIP, NodePort, LoadBalancer)
- ConfigMaps (environment variables)
- Secrets (database credentials, JWT secrets)
- Persistent Volumes (database storage)

**Code Standards**:
- Multi-stage Dockerfiles (build + runtime stages)
- Health checks (liveness, readiness probes)
- Resource limits (CPU, memory)
- Helm values.yaml for configuration

**Deliverables**:
- `phase-4/docker/` (Dockerfiles)
- `phase-4/k8s/` (raw manifests)
- `phase-4/helm/` (Helm chart)
- Local deployment instructions (no live URL)

### Phase 5: Cloud Deployment

**Technology Stack**:
- Cloud K8s: DigitalOcean DOKS or Oracle OKE
- Events: Kafka (Redpanda Cloud or Strimzi)
- Runtime: Dapr (Pub/Sub, State, Jobs, Secrets)
- CI/CD: GitHub Actions
- Monitoring: Basic logging (stdout/stderr)

**Dapr Components**:
- Pub/Sub (Kafka bindings)
- State Store (PostgreSQL)
- Secrets (Kubernetes secrets)
- Service-to-service calls (mTLS)

**Code Standards**:
- Dapr sidecars for all services
- Event-driven architecture (publish/subscribe)
- GitHub Actions workflows (build, test, deploy)
- Environment-specific configs (dev, staging, prod)

**Deliverables**:
- `phase-5/dapr/` (Dapr components)
- `phase-5/.github/workflows/` (CI/CD)
- Published cloud URL (required for submission)
- Cost estimate documentation

## Code Quality Standards

### Python (Backend)

**Mandatory**:
- Type hints on all function signatures
- Async/await for I/O operations (database, HTTP, file)
- Pydantic models for validation (requests, responses, configs)
- Proper error handling (try-except with specific exceptions)
- Environment variables for secrets (never hardcoded)
- Snake_case naming (functions, variables, files)

**Example**:
```python
async def get_user_todos(user_id: UUID, db: AsyncSession) -> list[TodoResponse]:
    """Fetch all todos for authenticated user."""
    try:
        result = await db.execute(
            select(Todo).where(Todo.user_id == user_id)
        )
        return [TodoResponse.from_orm(todo) for todo in result.scalars()]
    except SQLAlchemyError as e:
        logger.error(f"Database error fetching todos: {e}")
        raise HTTPException(status_code=500, detail="Database error")
```

### TypeScript (Frontend)

**Mandatory**:
- Strict mode enabled (`"strict": true` in tsconfig.json)
- Interfaces for all data shapes (API responses, props, state)
- Server Components by default (App Router)
- 'use client' directive only when needed (interactivity, hooks)
- Error boundaries for graceful failure handling

**Example**:
```typescript
interface Todo {
  id: string;
  title: string;
  completed: boolean;
  user_id: string;
  created_at: string;
}

async function TodoList({ userId }: { userId: string }) {
  const todos = await fetchTodos(userId); // Server Component
  return <div>{todos.map(todo => <TodoItem key={todo.id} todo={todo} />)}</div>;
}
```

### Database

**Mandatory**:
- UUID primary keys (never auto-increment integers)
- Indexes on foreign keys and frequently queried fields
- Timestamps (`created_at`, `updated_at`) on all tables
- Schema namespace: `phase2` (avoid Phase 1 conflicts)
- Migrations tracked (Alembic or SQLModel migrations)

**Example Schema**:
```sql
CREATE TABLE phase2.todos (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES phase2.users(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    completed BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_todos_user_id ON phase2.todos(user_id);
CREATE INDEX idx_todos_completed ON phase2.todos(completed);
```

### API Design

**Mandatory**:
- RESTful conventions (GET, POST, PUT, DELETE, PATCH)
- HTTP status codes:
  - 200 OK (successful GET/PUT/PATCH)
  - 201 Created (successful POST)
  - 204 No Content (successful DELETE)
  - 400 Bad Request (validation error)
  - 401 Unauthorized (missing/invalid token)
  - 403 Forbidden (insufficient permissions)
  - 404 Not Found (resource doesn't exist)
  - 409 Conflict (duplicate resource)
  - 422 Unprocessable Entity (semantic validation error)
  - 500 Internal Server Error (unexpected error)
- Proper error messages (user-friendly, actionable)
- API versioning if breaking changes needed (`/api/v1/`, `/api/v2/`)
- CORS properly configured (allow frontend origin)

**Example**:
```python
@router.post("/todos", status_code=201, response_model=TodoResponse)
async def create_todo(
    todo: TodoCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
) -> TodoResponse:
    """Create a new todo for authenticated user."""
    # Multi-tenant isolation enforced here
    new_todo = Todo(**todo.dict(), user_id=current_user.id)
    db.add(new_todo)
    await db.commit()
    await db.refresh(new_todo)
    return TodoResponse.from_orm(new_todo)
```

## Security Requirements

### Authentication & Authorization

**Mandatory**:
- Passwords hashed with bcrypt (10+ rounds, never plaintext)
- JWT secrets in environment variables (`.env` file, never committed)
- Token expiration (15 minutes access token, 7 days refresh token)
- Refresh token rotation (new token on each refresh)
- Multi-tenant isolation (user_id checks on every query)

### Data Protection

**Mandatory**:
- Never log sensitive data (passwords, tokens, PII)
- Input validation (Pydantic for Python, Zod for TypeScript)
- SQL injection prevention (parameterized queries, ORM)
- XSS prevention (React escapes by default, validate user input)
- CSRF protection (SameSite cookies, CORS configuration)

### Secrets Management

**Mandatory**:
- All secrets in environment variables
- `.env` file in `.gitignore` (never committed)
- `.env.example` with placeholder values (committed)
- Kubernetes Secrets for Phase 4-5 (base64 encoded)
- Dapr Secrets component for Phase 5

**Example `.env`**:
```bash
DATABASE_URL=postgresql://user:pass@host:5432/dbname
JWT_SECRET=your-secret-key-here-min-32-chars
OPENAI_API_KEY=sk-...
```

## Agents & Skills

### Available Agents (`.claude/agents/`)

1. **auth-agent**: Authentication, JWT, bcrypt, Better Auth patterns
2. **backend-agent**: FastAPI routes, schemas, middleware, error handling
3. **database-agent**: SQLModel, migrations, queries, indexes
4. **frontend-agent**: Next.js components, pages, Tailwind, client interactions
5. **ai-agent**: OpenAI Agents SDK, MCP server, tool calling
6. **devops-agent**: Docker, Kubernetes, Helm, CI/CD

### Available Skills (`.claude/skills/`)

1. **auth-skill**: JWT generation/validation, Better Auth patterns
2. **database-skill**: SQLModel ORM, PostgreSQL, migrations
3. **fastapi-backend-skill**: REST APIs, async endpoints, validation
4. **nextjs-frontend-skill**: App Router, React Server Components
5. **api-client-skill**: Axios, token handling, error interceptors
6. **openai-agents-skill**: Agents SDK, tool calling, streaming
7. **mcp-server-skill**: MCP tools, stateless design, database-backed
8. **docker-kubernetes-skill**: Containers, K8s manifests, Helm charts

### Agent Coordination

**When to use multiple agents**:
- Full-stack features (frontend-agent + backend-agent + database-agent)
- Authentication flows (auth-agent + backend-agent + database-agent)
- AI chatbot (ai-agent + backend-agent + database-agent)
- Deployment (devops-agent + backend-agent + frontend-agent)

**Coordination Protocol**:
1. Plan identifies which agents needed
2. Agents work in dependency order (database → backend → frontend)
3. Each agent validates its output before handoff
4. Integration testing after all agents complete

## Deliverables & Submission

### Required (All Phases)

- Public GitHub repository (all code, no private repos)
- Demo video (<90 seconds, NotebookLM or screen recording)
- README.md (setup instructions, architecture diagram)
- WhatsApp number (for presentation invite)

### Phase-Specific

**Phase 2 & 3**:
- Published app URL (Vercel deployment required)
- Database schema documentation
- API documentation (Swagger/OpenAPI)

**Phase 4**:
- Helm charts with templating
- Dockerfiles (multi-stage builds)
- Local deployment instructions
- No live URL required

**Phase 5**:
- Published cloud URL (required for submission)
- CI/CD pipeline (GitHub Actions)
- Cost estimate documentation
- Monitoring/logging setup

## Bonus Points Strategy

### Reusable Intelligence (+200 points)

**Criteria**:
- Skills created once, used across multiple phases
- Agents coordinate complex workflows autonomously
- Knowledge captured in `.claude/` folder (agents, skills, prompts)
- Documented patterns for future reuse

**Implementation**:
- Create generic skills (not phase-specific)
- Document agent coordination patterns
- Capture successful prompts in `.claude/prompts/`
- Build skill library that grows with each phase

### Cloud-Native Blueprints (+200 points)

**Criteria**:
- Helm charts with proper templating (values.yaml)
- Kubernetes manifests well-structured (namespaces, labels)
- Dapr components properly configured (Pub/Sub, State, Secrets)
- CI/CD pipeline functional (build, test, deploy)

**Implementation**:
- Helm chart with configurable values (replicas, resources, image tags)
- Kubernetes best practices (health checks, resource limits, labels)
- Dapr sidecar injection and component definitions
- GitHub Actions with multi-stage pipeline

### Urdu Support (+100 points)

**Criteria**:
- UI supports Urdu language (translations)
- Right-to-left (RTL) layout support
- Urdu natural language commands in chatbot
- Language switcher in UI

**Implementation**:
- i18n library (next-intl or react-i18next)
- RTL CSS (Tailwind RTL plugin)
- Urdu training data for chatbot
- Language detection and switching

### Voice Commands (+200 points)

**Criteria**:
- Speech-to-text integration (Web Speech API or Whisper)
- Voice-based todo creation ("Add buy milk to my todos")
- Hands-free operation (voice navigation)
- Audio feedback (text-to-speech responses)

**Implementation**:
- Web Speech API for browser-based STT
- OpenAI Whisper API for server-side STT
- Voice command parsing (intent detection)
- Text-to-speech for responses

## Non-Negotiables

**Workflow**:
- Strict SDD workflow (no code without specs)
- Constitution → Specify → Plan → Tasks → Implement
- All changes through spec updates only

**Structure**:
- Each phase in separate folder (`phase-1/`, `phase-2/`, etc.)
- Database schema evolution (not replacement)
- Backward compatibility maintained

**Architecture**:
- MCP tools MUST be stateless (no conversation state in server)
- Helm charts required for Kubernetes phases (4-5)
- Dapr for distributed runtime (Phase 5)
- All secrets externalized (never hardcoded)

**Security**:
- Multi-tenant isolation at all layers (database, application, API)
- JWT tokens for authentication (no session cookies)
- Passwords hashed with bcrypt (10+ rounds)
- Input validation on all endpoints

## Validation Criteria

### Before `/sp.implement`

**Gates (MUST pass)**:
- [ ] Constitution check passed (plan.md references this document)
- [ ] Spec clarity confirmed (no "NEEDS CLARIFICATION" markers)
- [ ] Plan reviewed (architecture decisions documented)
- [ ] Tasks validated (acceptance criteria defined, dependencies clear)

### After Implementation

**Acceptance (MUST pass)**:
- [ ] All acceptance criteria met (from spec.md)
- [ ] Multi-tenant isolation verified (test with 2+ users)
- [ ] Security requirements met (auth, validation, secrets)
- [ ] Code quality standards followed (linting, type checking)
- [ ] Phase independence maintained (previous phases untouched)
- [ ] Deliverables complete (README, demo video, URL if required)

### Testing Requirements

**Mandatory Tests**:
- Multi-tenant isolation (verify no cross-user data access)
- Authentication flows (signup, signin, token refresh, logout)
- CRUD operations (create, read, update, delete for all entities)
- Error handling (validation errors, auth errors, server errors)
- Edge cases (empty lists, duplicate entries, invalid input)

**Optional Tests** (if specified in spec):
- Unit tests (individual functions)
- Integration tests (multi-component workflows)
- Contract tests (API endpoint contracts)
- Performance tests (load testing, stress testing)

## Governance

**Authority**: This constitution supersedes all other practices, guidelines, and conventions. In case of conflict, constitution principles take precedence.

**Amendments**:
- Amendments require documentation in this file
- Version must be incremented (semantic versioning)
- Sync Impact Report must be generated
- Dependent templates must be updated (spec, plan, tasks)
- Migration plan required for breaking changes

**Compliance**:
- All PRs/reviews must verify compliance with constitution
- Complexity must be justified (document in plan.md)
- Use `CLAUDE.md` for runtime development guidance
- Constitution violations require explicit justification and approval

**Version Control**:
- MAJOR: Backward incompatible principle changes (e.g., removing multi-tenant requirement)
- MINOR: New principles or sections added (e.g., adding new phase standards)
- PATCH: Clarifications, wording, typo fixes (e.g., fixing example code)

**Review Cycle**:
- Constitution reviewed at end of each phase
- Lessons learned incorporated as amendments
- Successful patterns promoted to principles
- Failed patterns documented as anti-patterns

**Version**: 1.0.0 | **Ratified**: 2026-02-08 | **Last Amended**: 2026-02-08
